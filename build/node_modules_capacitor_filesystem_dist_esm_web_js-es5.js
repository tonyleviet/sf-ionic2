(function () {
  "use strict";

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  (self["webpackChunkphoto_gallery_ng_capacitor"] = self["webpackChunkphoto_gallery_ng_capacitor"] || []).push([["node_modules_capacitor_filesystem_dist_esm_web_js"], {
    /***/
    16603:
    /*!************************************************************!*\
      !*** ./node_modules/@capacitor/filesystem/dist/esm/web.js ***!
      \************************************************************/

    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "FilesystemWeb": function FilesystemWeb() {
          return (
            /* binding */
            _FilesystemWeb
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator */
      19369);
      /* harmony import */


      var _capacitor_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @capacitor/core */
      41899);

      function resolve(path) {
        var posix = path.split('/').filter(function (item) {
          return item !== '.';
        });
        var newPosix = [];
        posix.forEach(function (item) {
          if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {
            newPosix.pop();
          } else {
            newPosix.push(item);
          }
        });
        return newPosix.join('/');
      }

      function isPathParent(parent, children) {
        parent = resolve(parent);
        children = resolve(children);
        var pathsA = parent.split('/');
        var pathsB = children.split('/');
        return parent !== children && pathsA.every(function (value, index) {
          return value === pathsB[index];
        });
      }

      var _FilesystemWeb = /*#__PURE__*/function (_capacitor_core__WEBP) {
        _inherits(_FilesystemWeb, _capacitor_core__WEBP);

        var _super = _createSuper(_FilesystemWeb);

        function _FilesystemWeb() {
          var _this17;

          _classCallCheck(this, _FilesystemWeb);

          _this17 = _super.apply(this, arguments);
          _this17.DB_VERSION = 1;
          _this17.DB_NAME = 'Disc';
          _this17._writeCmds = ['add', 'put', 'delete'];
          return _this17;
        }

        _createClass(_FilesystemWeb, [{
          key: "initDb",
          value: function initDb() {
            var _this = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(_this._db !== undefined)) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return", _this._db);

                    case 2:
                      if ('indexedDB' in window) {
                        _context.next = 4;
                        break;
                      }

                      throw _this.unavailable("This browser doesn't support IndexedDB");

                    case 4:
                      return _context.abrupt("return", new Promise(function (resolve, reject) {
                        var request = indexedDB.open(_this.DB_NAME, _this.DB_VERSION);
                        request.onupgradeneeded = _FilesystemWeb.doUpgrade;

                        request.onsuccess = function () {
                          _this._db = request.result;
                          resolve(request.result);
                        };

                        request.onerror = function () {
                          return reject(request.error);
                        };

                        request.onblocked = function () {
                          console.warn('db blocked');
                        };
                      }));

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }))();
          }
        }, {
          key: "dbRequest",
          value: function dbRequest(cmd, args) {
            var _this2 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
              var readFlag;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      readFlag = _this2._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';
                      return _context2.abrupt("return", _this2.initDb().then(function (conn) {
                        return new Promise(function (resolve, reject) {
                          var tx = conn.transaction(['FileStorage'], readFlag);
                          var store = tx.objectStore('FileStorage');
                          var req = store[cmd].apply(store, _toConsumableArray(args));

                          req.onsuccess = function () {
                            return resolve(req.result);
                          };

                          req.onerror = function () {
                            return reject(req.error);
                          };
                        });
                      }));

                    case 2:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }))();
          }
        }, {
          key: "dbIndexRequest",
          value: function dbIndexRequest(indexName, cmd, args) {
            var _this3 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
              var readFlag;
              return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      readFlag = _this3._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';
                      return _context3.abrupt("return", _this3.initDb().then(function (conn) {
                        return new Promise(function (resolve, reject) {
                          var tx = conn.transaction(['FileStorage'], readFlag);
                          var store = tx.objectStore('FileStorage');
                          var index = store.index(indexName);
                          var req = index[cmd].apply(index, _toConsumableArray(args));

                          req.onsuccess = function () {
                            return resolve(req.result);
                          };

                          req.onerror = function () {
                            return reject(req.error);
                          };
                        });
                      }));

                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }))();
          }
        }, {
          key: "getPath",
          value: function getPath(directory, uriPath) {
            var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';
            var fsPath = '';
            if (directory !== undefined) fsPath += '/' + directory;
            if (uriPath !== '') fsPath += '/' + cleanedUriPath;
            return fsPath;
          }
        }, {
          key: "clear",
          value: function clear() {
            var _this4 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              var conn, tx, store;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return _this4.initDb();

                    case 2:
                      conn = _context4.sent;
                      tx = conn.transaction(['FileStorage'], 'readwrite');
                      store = tx.objectStore('FileStorage');
                      store.clear();

                    case 6:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }))();
          }
          /**
           * Read a file from disk
           * @param options options for the file read
           * @return a promise that resolves with the read file data result
           */

        }, {
          key: "readFile",
          value: function readFile(options) {
            var _this5 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              var path, entry;
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      path = _this5.getPath(options.directory, options.path); // const encoding = options.encoding;

                      _context5.next = 3;
                      return _this5.dbRequest('get', [path]);

                    case 3:
                      entry = _context5.sent;

                      if (!(entry === undefined)) {
                        _context5.next = 6;
                        break;
                      }

                      throw Error('File does not exist.');

                    case 6:
                      return _context5.abrupt("return", {
                        data: entry.content ? entry.content : ''
                      });

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }))();
          }
          /**
           * Write a file to disk in the specified location on device
           * @param options options for the file write
           * @return a promise that resolves with the file write result
           */

        }, {
          key: "writeFile",
          value: function writeFile(options) {
            var _this6 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
              var path, data, encoding, doRecursive, occupiedEntry, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;
              return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      path = _this6.getPath(options.directory, options.path);
                      data = options.data;
                      encoding = options.encoding;
                      doRecursive = options.recursive;
                      _context6.next = 6;
                      return _this6.dbRequest('get', [path]);

                    case 6:
                      occupiedEntry = _context6.sent;

                      if (!(occupiedEntry && occupiedEntry.type === 'directory')) {
                        _context6.next = 9;
                        break;
                      }

                      throw Error('The supplied path is a directory.');

                    case 9:
                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      _context6.next = 12;
                      return _this6.dbRequest('get', [parentPath]);

                    case 12:
                      parentEntry = _context6.sent;

                      if (!(parentEntry === undefined)) {
                        _context6.next = 19;
                        break;
                      }

                      subDirIndex = parentPath.indexOf('/', 1);

                      if (!(subDirIndex !== -1)) {
                        _context6.next = 19;
                        break;
                      }

                      parentArgPath = parentPath.substr(subDirIndex);
                      _context6.next = 19;
                      return _this6.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: doRecursive
                      });

                    case 19:
                      if (encoding) {
                        _context6.next = 23;
                        break;
                      }

                      data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;

                      if (_this6.isBase64String(data)) {
                        _context6.next = 23;
                        break;
                      }

                      throw Error('The supplied data is not valid base64 content.');

                    case 23:
                      now = Date.now();
                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'file',
                        size: data.length,
                        ctime: now,
                        mtime: now,
                        content: data
                      };
                      _context6.next = 27;
                      return _this6.dbRequest('put', [pathObj]);

                    case 27:
                      return _context6.abrupt("return", {
                        uri: pathObj.path
                      });

                    case 28:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }))();
          }
          /**
           * Append to a file on disk in the specified location on device
           * @param options options for the file append
           * @return a promise that resolves with the file write result
           */

        }, {
          key: "appendFile",
          value: function appendFile(options) {
            var _this7 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
              var path, data, encoding, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;
              return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      path = _this7.getPath(options.directory, options.path);
                      data = options.data;
                      encoding = options.encoding;
                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      now = Date.now();
                      ctime = now;
                      _context7.next = 8;
                      return _this7.dbRequest('get', [path]);

                    case 8:
                      occupiedEntry = _context7.sent;

                      if (!(occupiedEntry && occupiedEntry.type === 'directory')) {
                        _context7.next = 11;
                        break;
                      }

                      throw Error('The supplied path is a directory.');

                    case 11:
                      _context7.next = 13;
                      return _this7.dbRequest('get', [parentPath]);

                    case 13:
                      parentEntry = _context7.sent;

                      if (!(parentEntry === undefined)) {
                        _context7.next = 20;
                        break;
                      }

                      subDirIndex = parentPath.indexOf('/', 1);

                      if (!(subDirIndex !== -1)) {
                        _context7.next = 20;
                        break;
                      }

                      parentArgPath = parentPath.substr(subDirIndex);
                      _context7.next = 20;
                      return _this7.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: true
                      });

                    case 20:
                      if (!(!encoding && !_this7.isBase64String(data))) {
                        _context7.next = 22;
                        break;
                      }

                      throw Error('The supplied data is not valid base64 content.');

                    case 22:
                      if (occupiedEntry !== undefined) {
                        if (occupiedEntry.content !== undefined && !encoding) {
                          data = btoa(atob(occupiedEntry.content) + atob(data));
                        } else {
                          data = occupiedEntry.content + data;
                        }

                        ctime = occupiedEntry.ctime;
                      }

                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'file',
                        size: data.length,
                        ctime: ctime,
                        mtime: now,
                        content: data
                      };
                      _context7.next = 26;
                      return _this7.dbRequest('put', [pathObj]);

                    case 26:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }))();
          }
          /**
           * Delete a file from disk
           * @param options options for the file delete
           * @return a promise that resolves with the deleted file data result
           */

        }, {
          key: "deleteFile",
          value: function deleteFile(options) {
            var _this8 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
              var path, entry, entries;
              return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      path = _this8.getPath(options.directory, options.path);
                      _context8.next = 3;
                      return _this8.dbRequest('get', [path]);

                    case 3:
                      entry = _context8.sent;

                      if (!(entry === undefined)) {
                        _context8.next = 6;
                        break;
                      }

                      throw Error('File does not exist.');

                    case 6:
                      _context8.next = 8;
                      return _this8.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);

                    case 8:
                      entries = _context8.sent;

                      if (!(entries.length !== 0)) {
                        _context8.next = 11;
                        break;
                      }

                      throw Error('Folder is not empty.');

                    case 11:
                      _context8.next = 13;
                      return _this8.dbRequest('delete', [path]);

                    case 13:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }))();
          }
          /**
           * Create a directory.
           * @param options options for the mkdir
           * @return a promise that resolves with the mkdir result
           */

        }, {
          key: "mkdir",
          value: function mkdir(options) {
            var _this9 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
              var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;
              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      path = _this9.getPath(options.directory, options.path);
                      doRecursive = options.recursive;
                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      depth = (path.match(/\//g) || []).length;
                      _context9.next = 6;
                      return _this9.dbRequest('get', [parentPath]);

                    case 6:
                      parentEntry = _context9.sent;
                      _context9.next = 9;
                      return _this9.dbRequest('get', [path]);

                    case 9:
                      occupiedEntry = _context9.sent;

                      if (!(depth === 1)) {
                        _context9.next = 12;
                        break;
                      }

                      throw Error('Cannot create Root directory');

                    case 12:
                      if (!(occupiedEntry !== undefined)) {
                        _context9.next = 14;
                        break;
                      }

                      throw Error('Current directory does already exist.');

                    case 14:
                      if (!(!doRecursive && depth !== 2 && parentEntry === undefined)) {
                        _context9.next = 16;
                        break;
                      }

                      throw Error('Parent directory must exist');

                    case 16:
                      if (!(doRecursive && depth !== 2 && parentEntry === undefined)) {
                        _context9.next = 20;
                        break;
                      }

                      parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));
                      _context9.next = 20;
                      return _this9.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: doRecursive
                      });

                    case 20:
                      now = Date.now();
                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'directory',
                        size: 0,
                        ctime: now,
                        mtime: now
                      };
                      _context9.next = 24;
                      return _this9.dbRequest('put', [pathObj]);

                    case 24:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9);
            }))();
          }
          /**
           * Remove a directory
           * @param options the options for the directory remove
           */

        }, {
          key: "rmdir",
          value: function rmdir(options) {
            var _this10 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
              var path, directory, recursive, fullPath, entry, readDirResult, _iterator, _step, _entry, entryPath, entryObj;

              return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      path = options.path, directory = options.directory, recursive = options.recursive;
                      fullPath = _this10.getPath(directory, path);
                      _context10.next = 4;
                      return _this10.dbRequest('get', [fullPath]);

                    case 4:
                      entry = _context10.sent;

                      if (!(entry === undefined)) {
                        _context10.next = 7;
                        break;
                      }

                      throw Error('Folder does not exist.');

                    case 7:
                      if (!(entry.type !== 'directory')) {
                        _context10.next = 9;
                        break;
                      }

                      throw Error('Requested path is not a directory');

                    case 9:
                      _context10.next = 11;
                      return _this10.readdir({
                        path: path,
                        directory: directory
                      });

                    case 11:
                      readDirResult = _context10.sent;

                      if (!(readDirResult.files.length !== 0 && !recursive)) {
                        _context10.next = 14;
                        break;
                      }

                      throw Error('Folder is not empty');

                    case 14:
                      _iterator = _createForOfIteratorHelper(readDirResult.files);
                      _context10.prev = 15;

                      _iterator.s();

                    case 17:
                      if ((_step = _iterator.n()).done) {
                        _context10.next = 32;
                        break;
                      }

                      _entry = _step.value;
                      entryPath = "".concat(path, "/").concat(_entry.name);
                      _context10.next = 22;
                      return _this10.stat({
                        path: entryPath,
                        directory: directory
                      });

                    case 22:
                      entryObj = _context10.sent;

                      if (!(entryObj.type === 'file')) {
                        _context10.next = 28;
                        break;
                      }

                      _context10.next = 26;
                      return _this10.deleteFile({
                        path: entryPath,
                        directory: directory
                      });

                    case 26:
                      _context10.next = 30;
                      break;

                    case 28:
                      _context10.next = 30;
                      return _this10.rmdir({
                        path: entryPath,
                        directory: directory,
                        recursive: recursive
                      });

                    case 30:
                      _context10.next = 17;
                      break;

                    case 32:
                      _context10.next = 37;
                      break;

                    case 34:
                      _context10.prev = 34;
                      _context10.t0 = _context10["catch"](15);

                      _iterator.e(_context10.t0);

                    case 37:
                      _context10.prev = 37;

                      _iterator.f();

                      return _context10.finish(37);

                    case 40:
                      _context10.next = 42;
                      return _this10.dbRequest('delete', [fullPath]);

                    case 42:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, null, [[15, 34, 37, 40]]);
            }))();
          }
          /**
           * Return a list of files from the directory (not recursive)
           * @param options the options for the readdir operation
           * @return a promise that resolves with the readdir directory listing result
           */

        }, {
          key: "readdir",
          value: function readdir(options) {
            var _this11 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
              var path, entry, entries, files;
              return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      path = _this11.getPath(options.directory, options.path);
                      _context12.next = 3;
                      return _this11.dbRequest('get', [path]);

                    case 3:
                      entry = _context12.sent;

                      if (!(options.path !== '' && entry === undefined)) {
                        _context12.next = 6;
                        break;
                      }

                      throw Error('Folder does not exist.');

                    case 6:
                      _context12.next = 8;
                      return _this11.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);

                    case 8:
                      entries = _context12.sent;
                      _context12.next = 11;
                      return Promise.all(entries.map( /*#__PURE__*/function () {
                        var _ref = (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(e) {
                          var subEntry;
                          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                            while (1) {
                              switch (_context11.prev = _context11.next) {
                                case 0:
                                  _context11.next = 2;
                                  return _this11.dbRequest('get', [e]);

                                case 2:
                                  subEntry = _context11.sent;

                                  if (!(subEntry === undefined)) {
                                    _context11.next = 7;
                                    break;
                                  }

                                  _context11.next = 6;
                                  return _this11.dbRequest('get', [e + '/']);

                                case 6:
                                  subEntry = _context11.sent;

                                case 7:
                                  return _context11.abrupt("return", {
                                    name: e.substring(path.length + 1),
                                    type: subEntry.type,
                                    size: subEntry.size,
                                    ctime: subEntry.ctime,
                                    mtime: subEntry.mtime,
                                    uri: subEntry.path
                                  });

                                case 8:
                                case "end":
                                  return _context11.stop();
                              }
                            }
                          }, _callee11);
                        }));

                        return function (_x) {
                          return _ref.apply(this, arguments);
                        };
                      }()));

                    case 11:
                      files = _context12.sent;
                      return _context12.abrupt("return", {
                        files: files
                      });

                    case 13:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12);
            }))();
          }
          /**
           * Return full File URI for a path and directory
           * @param options the options for the stat operation
           * @return a promise that resolves with the file stat result
           */

        }, {
          key: "getUri",
          value: function getUri(options) {
            var _this12 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
              var path, entry;
              return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      path = _this12.getPath(options.directory, options.path);
                      _context13.next = 3;
                      return _this12.dbRequest('get', [path]);

                    case 3:
                      entry = _context13.sent;

                      if (!(entry === undefined)) {
                        _context13.next = 8;
                        break;
                      }

                      _context13.next = 7;
                      return _this12.dbRequest('get', [path + '/']);

                    case 7:
                      entry = _context13.sent;

                    case 8:
                      return _context13.abrupt("return", {
                        uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path
                      });

                    case 9:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13);
            }))();
          }
          /**
           * Return data about a file
           * @param options the options for the stat operation
           * @return a promise that resolves with the file stat result
           */

        }, {
          key: "stat",
          value: function stat(options) {
            var _this13 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
              var path, entry;
              return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      path = _this13.getPath(options.directory, options.path);
                      _context14.next = 3;
                      return _this13.dbRequest('get', [path]);

                    case 3:
                      entry = _context14.sent;

                      if (!(entry === undefined)) {
                        _context14.next = 8;
                        break;
                      }

                      _context14.next = 7;
                      return _this13.dbRequest('get', [path + '/']);

                    case 7:
                      entry = _context14.sent;

                    case 8:
                      if (!(entry === undefined)) {
                        _context14.next = 10;
                        break;
                      }

                      throw Error('Entry does not exist.');

                    case 10:
                      return _context14.abrupt("return", {
                        type: entry.type,
                        size: entry.size,
                        ctime: entry.ctime,
                        mtime: entry.mtime,
                        uri: entry.path
                      });

                    case 11:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14);
            }))();
          }
          /**
           * Rename a file or directory
           * @param options the options for the rename operation
           * @return a promise that resolves with the rename result
           */

        }, {
          key: "rename",
          value: function rename(options) {
            var _this14 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
              return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      _context15.next = 2;
                      return _this14._copy(options, true);

                    case 2:
                      return _context15.abrupt("return");

                    case 3:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15);
            }))();
          }
          /**
           * Copy a file or directory
           * @param options the options for the copy operation
           * @return a promise that resolves with the copy result
           */

        }, {
          key: "copy",
          value: function copy(options) {
            var _this15 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
              return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      return _context16.abrupt("return", _this15._copy(options, false));

                    case 1:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16);
            }))();
          }
        }, {
          key: "requestPermissions",
          value: function requestPermissions() {
            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
              return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      return _context17.abrupt("return", {
                        publicStorage: 'granted'
                      });

                    case 1:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17);
            }))();
          }
        }, {
          key: "checkPermissions",
          value: function checkPermissions() {
            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
              return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      return _context18.abrupt("return", {
                        publicStorage: 'granted'
                      });

                    case 1:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18);
            }))();
          }
          /**
           * Function that can perform a copy or a rename
           * @param options the options for the rename operation
           * @param doRename whether to perform a rename or copy operation
           * @return a promise that resolves with the result
           */

        }, {
          key: "_copy",
          value: function _copy(options) {
            var doRename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var _this16 = this;

            return (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
              var toDirectory, to, from, fromDirectory, fromPath, toPath, toObj, toPathComponents, _toPath, toParentDirectory, fromObj, updateTime, ctime, file, writeResult, contents, _iterator2, _step2, filename;

              return _regeneratorRuntime().wrap(function _callee20$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      toDirectory = options.toDirectory;
                      to = options.to, from = options.from, fromDirectory = options.directory;

                      if (!(!to || !from)) {
                        _context20.next = 4;
                        break;
                      }

                      throw Error('Both to and from must be provided');

                    case 4:
                      // If no "to" directory is provided, use the "from" directory
                      if (!toDirectory) {
                        toDirectory = fromDirectory;
                      }

                      fromPath = _this16.getPath(fromDirectory, from);
                      toPath = _this16.getPath(toDirectory, to); // Test that the "to" and "from" locations are different

                      if (!(fromPath === toPath)) {
                        _context20.next = 9;
                        break;
                      }

                      return _context20.abrupt("return", {
                        uri: toPath
                      });

                    case 9:
                      if (!isPathParent(fromPath, toPath)) {
                        _context20.next = 11;
                        break;
                      }

                      throw Error('To path cannot contain the from path');

                    case 11:
                      _context20.prev = 11;
                      _context20.next = 14;
                      return _this16.stat({
                        path: to,
                        directory: toDirectory
                      });

                    case 14:
                      toObj = _context20.sent;
                      _context20.next = 28;
                      break;

                    case 17:
                      _context20.prev = 17;
                      _context20.t0 = _context20["catch"](11);
                      // To location does not exist, ensure the directory containing "to" location exists and is a directory
                      toPathComponents = to.split('/');
                      toPathComponents.pop();
                      _toPath = toPathComponents.join('/'); // Check the containing directory of the "to" location exists

                      if (!(toPathComponents.length > 0)) {
                        _context20.next = 28;
                        break;
                      }

                      _context20.next = 25;
                      return _this16.stat({
                        path: _toPath,
                        directory: toDirectory
                      });

                    case 25:
                      toParentDirectory = _context20.sent;

                      if (!(toParentDirectory.type !== 'directory')) {
                        _context20.next = 28;
                        break;
                      }

                      throw new Error('Parent directory of the to path is a file');

                    case 28:
                      if (!(toObj && toObj.type === 'directory')) {
                        _context20.next = 30;
                        break;
                      }

                      throw new Error('Cannot overwrite a directory with a file');

                    case 30:
                      _context20.next = 32;
                      return _this16.stat({
                        path: from,
                        directory: fromDirectory
                      });

                    case 32:
                      fromObj = _context20.sent;

                      // Set the mtime/ctime of the supplied path
                      updateTime = /*#__PURE__*/function () {
                        var _ref2 = (0, _Users_vietle_Projects_ionic_sf_ionic2_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(path, ctime, mtime) {
                          var fullPath, entry;
                          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
                            while (1) {
                              switch (_context19.prev = _context19.next) {
                                case 0:
                                  fullPath = _this16.getPath(toDirectory, path);
                                  _context19.next = 3;
                                  return _this16.dbRequest('get', [fullPath]);

                                case 3:
                                  entry = _context19.sent;
                                  entry.ctime = ctime;
                                  entry.mtime = mtime;
                                  _context19.next = 8;
                                  return _this16.dbRequest('put', [entry]);

                                case 8:
                                case "end":
                                  return _context19.stop();
                              }
                            }
                          }, _callee19);
                        }));

                        return function updateTime(_x2, _x3, _x4) {
                          return _ref2.apply(this, arguments);
                        };
                      }();

                      ctime = fromObj.ctime ? fromObj.ctime : Date.now();
                      _context20.t1 = fromObj.type;
                      _context20.next = _context20.t1 === 'file' ? 38 : _context20.t1 === 'directory' ? 51 : 86;
                      break;

                    case 38:
                      _context20.next = 40;
                      return _this16.readFile({
                        path: from,
                        directory: fromDirectory
                      });

                    case 40:
                      file = _context20.sent;

                      if (!doRename) {
                        _context20.next = 44;
                        break;
                      }

                      _context20.next = 44;
                      return _this16.deleteFile({
                        path: from,
                        directory: fromDirectory
                      });

                    case 44:
                      _context20.next = 46;
                      return _this16.writeFile({
                        path: to,
                        directory: toDirectory,
                        data: file.data
                      });

                    case 46:
                      writeResult = _context20.sent;

                      if (!doRename) {
                        _context20.next = 50;
                        break;
                      }

                      _context20.next = 50;
                      return updateTime(to, ctime, fromObj.mtime);

                    case 50:
                      return _context20.abrupt("return", writeResult);

                    case 51:
                      if (!toObj) {
                        _context20.next = 53;
                        break;
                      }

                      throw Error('Cannot move a directory over an existing object');

                    case 53:
                      _context20.prev = 53;
                      _context20.next = 56;
                      return _this16.mkdir({
                        path: to,
                        directory: toDirectory,
                        recursive: false
                      });

                    case 56:
                      if (!doRename) {
                        _context20.next = 59;
                        break;
                      }

                      _context20.next = 59;
                      return updateTime(to, ctime, fromObj.mtime);

                    case 59:
                      _context20.next = 63;
                      break;

                    case 61:
                      _context20.prev = 61;
                      _context20.t2 = _context20["catch"](53);

                    case 63:
                      _context20.next = 65;
                      return _this16.readdir({
                        path: from,
                        directory: fromDirectory
                      });

                    case 65:
                      contents = _context20.sent.files;
                      _iterator2 = _createForOfIteratorHelper(contents);
                      _context20.prev = 67;

                      _iterator2.s();

                    case 69:
                      if ((_step2 = _iterator2.n()).done) {
                        _context20.next = 75;
                        break;
                      }

                      filename = _step2.value;
                      _context20.next = 73;
                      return _this16._copy({
                        from: "".concat(from, "/").concat(filename),
                        to: "".concat(to, "/").concat(filename),
                        directory: fromDirectory,
                        toDirectory: toDirectory
                      }, doRename);

                    case 73:
                      _context20.next = 69;
                      break;

                    case 75:
                      _context20.next = 80;
                      break;

                    case 77:
                      _context20.prev = 77;
                      _context20.t3 = _context20["catch"](67);

                      _iterator2.e(_context20.t3);

                    case 80:
                      _context20.prev = 80;

                      _iterator2.f();

                      return _context20.finish(80);

                    case 83:
                      if (!doRename) {
                        _context20.next = 86;
                        break;
                      }

                      _context20.next = 86;
                      return _this16.rmdir({
                        path: from,
                        directory: fromDirectory
                      });

                    case 86:
                      return _context20.abrupt("return", {
                        uri: toPath
                      });

                    case 87:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee20, null, [[11, 17], [53, 61], [67, 77, 80, 83]]);
            }))();
          }
        }, {
          key: "isBase64String",
          value: function isBase64String(str) {
            try {
              return btoa(atob(str)) == str;
            } catch (err) {
              return false;
            }
          }
        }], [{
          key: "doUpgrade",
          value: function doUpgrade(event) {
            var eventTarget = event.target;
            var db = eventTarget.result;

            switch (event.oldVersion) {
              case 0:
              case 1:
              default:
                {
                  if (db.objectStoreNames.contains('FileStorage')) {
                    db.deleteObjectStore('FileStorage');
                  }

                  var store = db.createObjectStore('FileStorage', {
                    keyPath: 'path'
                  });
                  store.createIndex('by_folder', 'folder');
                }
            }
          }
        }]);

        return _FilesystemWeb;
      }(_capacitor_core__WEBPACK_IMPORTED_MODULE_1__.WebPlugin);

      _FilesystemWeb._debug = true;
      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_capacitor_filesystem_dist_esm_web_js-es5.js.map